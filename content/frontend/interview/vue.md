# Vue

## 生命周期

## 状态管理

## vue3

### Composition API

### 自定义hooks

### 响应式升级

### diff算法升级

### Teleport

### Suspense

### Fragment

### Tree-Shaking

### 其他

- 插槽
- 自定义指令
- v-model升级
- 异步组件

## 源码分析

### diff

vue2 Diff算法(采用了双端Diff算法)

- 对比头头、尾尾、头尾、尾头是否可以复用，如果可以复用，就进行节点的更新和移动操作
- 如果经过四个端点的比较，都没有可复用的节点，则将
- 拿新的一组子节点的头部去map中查找，如果找到可复用的节点，则将相应的节点进行更新，并将其移动到头部，然后头部指针右移
- 然而，拿新的一组子节点的头部节点去旧的一组子节点中寻找可复用的节点，并非总能找到，这说明这个新的头部节点是新增节点，只需要将其挂载到头部即可
- 经过上述处理，最后还剩下新的节点就批量新增，剩下旧的节点就批量删除

- 同层级比较：Vue2的Diff算法只会在同一层级进行比较，不会跨层级比较。这样可以大大减少比较的复杂度，提高性能
- 节点比较：比较两个节点时，如果类型不同，则直接删除旧节点，创建并插入新节点，如果类型相同，那么继续比较节点的属性和子节点
- 列表比较：在比较列表时，vue2使用了一种叫双端比较的策略，首先同时从两个列表的头部和尾部开始比较，如果头部或尾部的节点相同，那么直接更新节点。如果头尾都不同，那么通过一个键值对的映射关系找到相同的节点，然后进行移动。这种策略可以有效地处理列表的顺序变化
- 子节点比较：在比较子节点时，如果新的子节点是文本节点，那么直接更新文本内容，如果新的子节点是数组，那么使用列表比较的策略进行比较

vue3 Diff算法(在vue2的基础上进行了优化，主要改进在于引入了静态节点标记和块的概念)

- 静态节点标记：编译器会对静态节点进行标记，这样在更新过程中就可以直接跳过这些节点，不需要进行更新和比较
- 块的概念：每个块对应一个动态节点或组件，在更新过程中，只需要更新改变的块，而不需要更新整个组件，这样可以减少不必要的渲染，提高性能
- 优化列表渲染（LCS longest increasing subsequence）最长递增序列
  - 通过LCS算法，Vue可以找出列表中顺序变化最小的一种方式，也就是找出最长的不需要移动的子序列，然后只移动其它需要移动的元素，这样可以大大减少DOM操作的数量
  - LCS算法是一种动态规划算法，主要思想是通过比较新旧列表，找出两者之间最长的相同子序列，然后保持这个子序列不动只移动其它元素
- 优化组件更新

### nextTick

在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM

### 虚拟DOM

### 双向绑定原理

Object.difineProperty 和 Proxy

- Object.defineProperty 只能劫持对象的属性，Proxy是直接代理对象
  - 由于Object.defineProperty只能劫持对象的属性，需要遍历对象的每一个属性，如果属性值也是对象，则需要递归进行深度遍历。
- Object.defineProperty 新增属性需要手动进行Observe
  - 新增属性时，也需要重新遍历对象，对新增的属性再次使用Object.defineProperty进行劫持

### h 函数

_createVNode函数做的事情

- 标准化props class
- 给VNode打上编码标记
- 创建VNode
- 标准化子节点

```js
// 除了类型必填以外，其他的参数都是可选的
h('div')
h('div', { id: 'foo' })

// attribute 和 property 都能在 prop 中书写
// Vue 会自动将它们分配到正确的位置
h('div', { class: 'bar', innerHTML: 'hello' })

// 像 `.prop` 和 `.attr` 这样的的属性修饰符
// 可以分别通过 `.` 和 `^` 前缀来添加
h('div', { '.name': 'some-name', '^width': '100' })

// 类与样式可以像在模板中一样
// 用数组或对象的形式书写
h('div', { class: [foo, { bar }], style: { color: 'red' } })

// 事件监听器应以 onXxx 的形式书写
h('div', { onClick: () => {} })

// children 可以是一个字符串
h('div', { id: 'foo' }, 'hello')

// 没有 props 时可以省略不写
h('div', 'hello')
h('div', [h('span', 'hello')])

// children 数组可以同时包含 vnodes 与字符串
h('div', ['hello', h('span', 'hello')])
```
